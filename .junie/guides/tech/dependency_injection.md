# Dependency Injection Guidelines

Purpose: Establish consistent DI patterns using Metro for Kotlin Multiplatform with compile-time graph validation and vertical-slice feature modules.

References
- Metro docs and API: zacsweers.github.io/metro (compile-time DI, K2, KSP, multiplatform)
- Examples in this guide are adapted from Metro reference docs such as dependency-graphs and aggregation pages.

## Framework Choice
- We use Metro across all platforms. It’s Kotlin Multiplatform-ready and performs full binding graph validation at compile time.
- Prefer constructor injection via `@Inject` and explicit providers via `@Provides`.
- Use Metro’s scopes, graph factories, and contribution annotations to wire feature modules cleanly.

## Architecture: Vertical Slices with api/impl
- Each feature lives in its own set of modules using the pattern:
  - :features:<feature-name>:api — public contracts (interfaces, models that need to be shared), navigation contracts, and DI entry points to be consumed by other features.
  - :features:<feature-name>:impl — private implementations, internal mappers, data sources, and DI contributions using Metro annotations.
- Only the `api` modules are visible to other features; `impl` remains private. `impl` contributes bindings to the application graph.

## Location and Structure
- DI code that declares the app/root graph lives in a top-level commonMain module (e.g., `composeApp/src/commonMain/.../di`).
- Feature-specific DI contributions live in each feature’s `impl` module under `src/commonMain/.../di`.
- Platform-specific DI (if needed) is placed in platform source sets. Prefer commonMain where possible.

## Defining the App Graph

```kotlin
// Define an application scope marker
interface AppScope

// Root graph defines app-wide dependencies
@DependencyGraph
interface AppGraph {
  val loggerSet: Set<Logger> // example multibinding

  @DependencyGraph.Factory
  fun interface Factory {
    // Factory can accept runtime inputs using @Provides
    fun create(@Provides baseUrl: String): AppGraph
  }
}
```

Notes
- Use `@DependencyGraph` for the root. Metro generates an `$$MetroGraph` implementation.
- Use a `Factory` to pass runtime parameters (e.g., base URL, configs) using `@Provides`.

## Providing and Binding Dependencies

```kotlin
// Simple provider inside a graph or contributed graph
@Provides
fun provideHttpClient(): HttpClient = buildHttpClient()

// Binding an implementation to an interface within a scope
@ContributesBinding(AppScope::class)
@SingleIn(AppScope::class)
@Inject
class RealUserRepository(
  private val api: UserApiService,
  private val storage: UserStorage
) : UserRepository
```

Multibinding (sets/maps)
```kotlin
// Contribute into a Set<Logger>
@ContributesIntoSet(AppScope::class)
@Inject
class ConsoleLogger : Logger

@ContributesIntoSet(AppScope::class)
@Inject
class CrashLogger : Logger
```

Consumers receive collections directly
```kotlin
class AppLogger @Inject constructor(
  private val loggers: Set<Logger>
) : Logger { /* delegate to all */ }
```

## Feature Modules and DI

In :features:<name>:api
- Expose only the contracts needed cross-feature (e.g., `UserRepository`, navigation contracts, and any domain/use case interfaces that other features must call). Avoid leaking implementation details.

In :features:<name>:impl
- Implement the contracts and contribute them to the `AppScope` via `@ContributesBinding` (and `@SingleIn` as appropriate).
- Provide feature-scoped factories when needed using Metro graph extensions.

```kotlin
// features/profile/api/src/commonMain/.../ProfileRepository.kt
interface ProfileRepository { suspend fun load(): Either<RepoError, Profile> }

// features/profile/impl/src/commonMain/.../di/ProfileBindings.kt
@ContributesBinding(AppScope::class)
@SingleIn(AppScope::class)
@Inject
class RealProfileRepository(
  private val api: ProfileApiService
) : ProfileRepository
```

## Graph Extensions for Subgraphs
Use graph extensions for lifecycle or contextual scopes (e.g., logged-in user):

```kotlin
@ContributesGraphExtension(LoggedInScope::class)
interface LoggedInGraph {
  val sessionUser: SessionUser

  @ContributesGraphExtension.Factory(AppScope::class)
  interface Factory {
    fun createLoggedInGraph(@Provides userId: String): LoggedInGraph
  }
}
```

## Initialization
- Construct the app graph at startup via the generated factory. Provide runtime parameters via `@Provides` args.

```kotlin
// Pseudo-code: exact API is generated by Metro for your graph.
// Common options include a companion `invoke` or a generated Factory.

// Example options (one of these will exist after compilation):
// val appGraph: AppGraph = AppGraph(/* @Provides args like baseUrl */)
// val appGraph: AppGraph = AppGraph.Factory.create(/* baseUrl */)

// Keep a singleton reference you can pass where needed
object DI {
  lateinit var appGraph: AppGraph
    private set

  fun init(baseUrl: String) {
    // initialize appGraph using the generated factory for AppGraph
    // e.g., appGraph = AppGraph.Factory.create(baseUrl)
  }
}
```

Tip: The exact invocation depends on the generated API for your graph (see Metro docs). Generally there is a factory or `invoke` operator on the companion.

## Platform-Specific Dependencies
- Use expect/actual when you must bind platform-specific services. Contribute the actuals in platform source sets and expose their contracts in commonMain.

## Best Practices
- Keep DI setup in commonMain where feasible; isolate platform specifics.
- Prefer small graphs and contributed bindings over large monoliths.
- Use `@SingleIn` for repositories, network clients, and stateful services; use unscoped/`factory`-like patterns for ephemeral objects.
- Validate module visibility: only `api` modules are visible to other features; `impl` should not be exported.

## iOS Umbrella (shared module)
- The `shared` module is an umbrella framework for the iOS app. It exports all required feature `api` modules and any public-facing contracts while keeping implementations internal. Ensure Gradle `export` entries include only the `api` modules that the iOS wrapper must see.

## Testing Considerations
- For tests, construct small test graphs or directly instantiate classes with fakes/mocks. Metro validates graphs at compile time; prefer unit tests with constructor injection over heavy DI bootstrapping in tests.

Notes from Metro docs
- Metro performs full binding graph validation and supports K2/KSP. See the official docs for `@DependencyGraph`, `@Provides`, `@ContributesBinding`, `@ContributesIntoSet`, and graph extension patterns.
