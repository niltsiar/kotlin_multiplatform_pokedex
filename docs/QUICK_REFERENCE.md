# Quick Reference Guide

Last Updated: December 20, 2025

> Fast lookup for commands, tables, API references, and common patterns.

## Agent Selector (Quick)

Use these specialized modes for faster task routing:

- Product Design Mode ‚Üí [docs/agent-prompts/product_designer_agent_system_prompt_DELTA.md](agent-prompts/product_designer_agent_system_prompt_DELTA.md)
- UI/UX Design Mode ‚Üí [docs/agent-prompts/uiux_agent_system_prompt_DELTA.md](agent-prompts/uiux_agent_system_prompt_DELTA.md)
- Screen Implementation Mode ‚Üí [docs/agent-prompts/ui_ux_system_agent_for_generic_screen_DELTA.md](agent-prompts/ui_ux_system_agent_for_generic_screen_DELTA.md)
- SwiftUI Screen Agent ‚Üí [docs/agent-prompts/ui_ux_system_agent_for_swiftui_screen_DELTA.md](agent-prompts/ui_ux_system_agent_for_swiftui_screen_DELTA.md)
- Onboarding Design Mode ‚Üí [docs/agent-prompts/onboarding_agent_system_prompt_DELTA.md](agent-prompts/onboarding_agent_system_prompt_DELTA.md)
- User Flow Planning Mode ‚Üí [docs/agent-prompts/user_flow_agent_system_prompt_DELTA.md](agent-prompts/user_flow_agent_system_prompt_DELTA.md)
- Testing Strategy Mode ‚Üí [docs/agent-prompts/testing_agent_system_prompt_DELTA.md](agent-prompts/testing_agent_system_prompt_DELTA.md)
- Backend Development Mode ‚Üí [docs/agent-prompts/backend_agent_system_prompt_DELTA.md](agent-prompts/backend_agent_system_prompt_DELTA.md)
- Documentation Management Mode ‚Üí [docs/agent-prompts/documentation_agent_system_prompt_DELTA.md](agent-prompts/documentation_agent_system_prompt_DELTA.md)

Tip: For a browsable list with brief purposes, see [docs/agent-prompts/README.md](agent-prompts/README.md). For detailed routing and sync guardrails, see [AGENTS.md](../AGENTS.md).

## Essential Commands

### Primary Validation (ALWAYS RUN FIRST)
```bash
# Android build + ALL tests (fastest feedback: ~45 seconds)
./gradlew :composeApp:assembleDebug test --continue
```

### Dependency Management
```bash
# Check for available updates
./gradlew dependencyUpdates

# View detailed report
open build/dependencyUpdates/report.html
```

**Stability Rules** (configured in root `build.gradle.kts`):
- ‚úÖ Stable versions stay stable (e.g., `2.8.4` won't upgrade to `2.9.0-alpha01`)
- ‚úÖ Unstable versions upgrade within same major.minor:
  - `2.9.0-alpha01` ‚Üí `2.9.0-alpha03` ‚úÖ (same major.minor)
  - `2.9.0-alpha01` ‚Üí `2.9.0-beta01` ‚úÖ (same major.minor)
  - `2.9.0-alpha01` ‚Üí `2.10.0-alpha01` ‚ùå (different minor)
- ‚úÖ Unstable versions upgrade to ANY stable version:
  - `2.9.0-alpha02` ‚Üí `3.1.1` ‚úÖ (stable release)

### Platform-Specific Commands
```bash
# Desktop/JVM
./gradlew :composeApp:run

# Ktor Server (port 8080)
./gradlew :server:run

# Android build
./gradlew :composeApp:assembleDebug

# Unit tests
./gradlew :composeApp:testDebugUnitTest

# Screenshot tests
./gradlew recordRoborazziDebug              # Record baselines
./gradlew verifyRoborazziDebug              # Verify against baselines
./gradlew compareRoborazziDebug             # Compare screenshots
```

### Commits & Changelog
```bash
# Commit with Conventional Commits format (required)
git commit -m "type(scope): description"

# Types: feat, fix, docs, test, build, refactor, chore
# Examples:
git commit -m "feat(pokemonlist): add search functionality"
git commit -m "refactor(navigation): align package with folder structure"
git commit -m "docs(conventions): update testing requirements"

# Regenerate CHANGELOG.md from commits (using git-cliff)
git cliff -o CHANGELOG.md

# Preview changelog without writing
git cliff --dry-run
```

**CHANGELOG Policy:**
- ‚ùå **DO NOT manually edit CHANGELOG.md** ‚Äî it's auto-generated by git-cliff
- ‚úÖ Use proper Conventional Commits format ‚Äî git-cliff parses these automatically
- ‚úÖ Regenerate changelog before releases: `git cliff -o CHANGELOG.md`
- ‚úÖ Commit types map to changelog sections:
  - `feat` ‚Üí ‚ú® Features
  - `fix` ‚Üí üêõ Bug Fixes
  - `docs` ‚Üí üìù Documentation
  - `test` ‚Üí ‚úÖ Tests
  - `build` ‚Üí üîß Build System
  - `refactor` ‚Üí ‚ôªÔ∏è Refactoring
  - `chore` ‚Üí üßπ Chores

### iOS Build Policy ‚ö†Ô∏è
**NEVER run iOS builds during routine validation** (5-10min builds).

Only execute when:
1. Explicitly requested by user
2. Testing iOS framework exports
3. Validating iOS-specific expect/actual implementations
4. Working on SwiftUI integration with shared.framework

**iOS Commands** (use sparingly):
```bash
# Build shared framework for iOS
./gradlew :shared:embedAndSignAppleFrameworkForXcode

# Open iOS projects in Xcode
open iosApp/iosApp.xcodeproj                # Native SwiftUI app (production)
open iosAppCompose/iosAppCompose.xcodeproj  # Compose iOS app (experimental)
```

### Gradle Utility Commands
```bash
# Show module structure
./gradlew projects

# Show dependency tree
./gradlew :composeApp:dependencies

# Check for dependency conflicts
./gradlew :composeApp:dependencyInsight --dependency arrow-core

# Refresh dependencies
./gradlew --refresh-dependencies

# Clean build
./gradlew clean
```

## Test Enforcement Matrix

| Production Code | Test Location | Framework | Property Tests Required |
|----------------|---------------|-----------|------------------------|
| Repository | androidUnitTest/ | Kotest + MockK + Turbine | HTTP error ranges, ID preservation |
| ViewModel | androidUnitTest/ | Kotest + MockK + Turbine | State transitions with random data |
| Mapper | androidUnitTest/ | Kotest properties | Data preservation invariants |
| Use Case | androidUnitTest/ | Kotest + MockK | Business rule validation |
| API Service | androidUnitTest/ | Kotest + MockK | HTTP mocking |
| @Composable | Same file | @Preview + Roborazzi | N/A |
| Simple Utility | commonTest/ | kotlin-test | Input/output validation |

**Coverage Targets:**
- Overall: 30-40% of tests should be property-based
- Mappers: 100% property tests
- Repositories: 40-50% property tests
- ViewModels: 30-40% property tests

## SavedStateHandle Quick Reference

**Purpose:** Persist ViewModel state across configuration changes and process death.

**Platform Support:**
- ‚úÖ Android: Full native support
- ‚úÖ Desktop/JVM: Manual creation
- ‚ö†Ô∏è iOS: App state restoration (different lifecycle than Android)

**Current Pattern (Delegate - SavedState 1.4.0+):**
```kotlin
import androidx.lifecycle.serialization.saved

class MyViewModel(
    private val repository: MyRepository,
    private val savedStateHandle: SavedStateHandle,  // ‚Üê Always inject
    viewModelScope: CoroutineScope = ...
) : ViewModel(viewModelScope), DefaultLifecycleObserver {
    
    // ‚ú® Single line - automatic persistence
    private var state by savedStateHandle.saved { MyState() }
    
    fun updateData() {
        state = state.copy(...)  // ‚Üê Automatically persisted on write!
        // No persistState() call needed
    }
}
```

**Why This Works:**
- ‚úÖ **93% code reduction** - Eliminates ~28 lines of boilerplate per ViewModel
- ‚úÖ **Automatic persistence** - State saved on every property write
- ‚úÖ **Type-safe** - Uses kotlinx.serialization internally
- ‚úÖ **KMP compatible** - Works in `commonMain` source set
- ‚úÖ **No manual calls** - No `persistState()` functions or key management

**Critical: Use Correct Import!**
```kotlin
// ‚úÖ CORRECT - For SavedStateHandle delegate
import androidx.lifecycle.serialization.saved

// ‚ùå WRONG - For SavedStateRegistryOwner (different use case)
import androidx.savedstate.serialization.saved
```

**Requirements:**
- AndroidX SavedState 1.4.0+
- AndroidX Lifecycle 2.10.0-alpha07+
- State type must be `@Serializable`

**Legacy Pattern (Manual - Pre-1.4.0):**
```kotlin
import kotlinx.serialization.json.Json
import kotlinx.serialization.encodeToString
import kotlinx.serialization.decodeFromString

class MyViewModel(
    private val repository: MyRepository,
    private val savedStateHandle: SavedStateHandle,
    viewModelScope: CoroutineScope = ...
) : ViewModel(viewModelScope), DefaultLifecycleObserver {
    
    private val json = Json { ignoreUnknownKeys = true; encodeDefaults = true }
    
    // Manual restoration from SavedStateHandle
    private var state: MyState = savedStateHandle
        .get<String>(KEY_STATE)
        ?.let { json.decodeFromString(it) }
        ?: MyState()
    
    private fun persistState() {
        savedStateHandle[KEY_STATE] = json.encodeToString(state)
    }
    
    fun updateData() {
        state = state.copy(...)
        persistState()  // ‚Üê Must call manually after every mutation
    }
    
    companion object {
        private const val KEY_STATE = "state"
    }
}
```

**Koin Wiring:**
```kotlin
// Android (auto-provides)
viewModel { PokemonListViewModel(get(), SavedStateHandle()) }

// Desktop/JVM (manual creation)
viewModel { PokemonListViewModel(get(), SavedStateHandle()) }
```

**Testing:**
```kotlin
beforeTest {
    viewModel = MyViewModel(
        repository = mockRepository,
        savedStateHandle = SavedStateHandle(),  // ‚Üê Always provide
        viewModelScope = testScope
    )
}
```

**Reference Implementations:**
- [PokemonListViewModel.kt](../features/pokemonlist/presentation/src/commonMain/kotlin/com/minddistrict/multiplatformpoc/features/pokemonlist/presentation/PokemonListViewModel.kt) (delegate pattern)
- [PokemonDetailViewModel.kt](../features/pokemondetail/presentation/src/commonMain/kotlin/com/minddistrict/multiplatformpoc/features/pokemondetail/presentation/PokemonDetailViewModel.kt) (delegate pattern)
- [DI Patterns Guide](patterns/di_patterns.md#savedstatehandle-in-viewmodels)

## Module Structure Reference

### Current Modules
```
:composeApp           ‚Üí Compose Multiplatform UI (Android + Desktop + iOS)
:shared               ‚Üí iOS umbrella framework (exports other modules)
:iosApp               ‚Üí Native SwiftUI iOS app (production)
:iosAppCompose        ‚Üí Compose Multiplatform iOS app (experimental)
:server               ‚Üí Ktor Backend-for-Frontend (BFF)
```

### Feature Module Pattern
```
:features:<feature>:api           ‚Üí Public contracts (exported to iOS)
:features:<feature>:data          ‚Üí Network + Data layer (NOT exported)
:features:<feature>:presentation  ‚Üí ViewModels, UI state (exported to iOS)
:features:<feature>:ui            ‚Üí Compose UI screens (NOT exported)
:features:<feature>:wiring        ‚Üí DI assembly (NOT exported)
```

### Core Modules (Use Sparingly)
```
:core:designsystem   ‚Üí Material 3 theme, reusable Compose components
:core:navigation     ‚Üí Navigation 3 modular architecture
:core:di             ‚Üí Koin DI core module
:core:httpclient     ‚Üí Ktor HttpClient configuration
:core:util           ‚Üí Generic utilities (3+ features use it)
```

## iOS Export Rules

**Exported to iOS** (via `:shared` umbrella):
- ‚úÖ `:features:*:api` ‚Äî Public contracts
- ‚úÖ `:features:*:presentation` ‚Äî ViewModels, UI state
- ‚úÖ `:core:*` modules ‚Äî Shared infrastructure

**NOT Exported to iOS**:
- ‚ùå `:features:*:data` ‚Äî Internal data layer
- ‚ùå `:features:*:ui` ‚Äî Compose UI (Android/Desktop/iOS Compose only)
- ‚ùå `:features:*:wiring` ‚Äî DI assembly
- ‚ùå `:composeApp` ‚Äî Compose UI framework

**Note:** Native SwiftUI iosApp doesn't use Compose UI. iosAppCompose (experimental) uses Compose UI from :composeApp.

## Turbine API Quick Reference

| Method | Use Case | Example |
|--------|----------|---------|
| `awaitItem()` | Get next emission (fails if none) | `val item = awaitItem()` |
| `skipItems(n)` | Skip n emissions | `skipItems(2)` |
| `expectNoEvents()` | Assert no emissions occurred | `expectNoEvents()` |
| `cancelAndIgnoreRemainingEvents()` | Clean teardown | Always call at end |
| `.test { }` | Turbine test block for flows | `flow.test { /* assertions */ }` |

**Pattern:**
```kotlin
viewModel.uiState.test {
    awaitItem() shouldBe Loading
    viewModel.loadInitialPage()  // Call public methods directly
    testScope.advanceUntilIdle()
    awaitItem().shouldBeInstanceOf<Content>()
    cancelAndIgnoreRemainingEvents()
}

// Separate test for lifecycle integration
"onStart should trigger loading" {
    val viewModel = createViewModel()
    val lifecycleOwner = TestLifecycleOwner(Lifecycle.State.STARTED)
    
    viewModel.onStart(lifecycleOwner)
    testScope.advanceUntilIdle()
    
    viewModel.uiState.value shouldBeInstanceOf<Content>()
}
```

## Common Violations & Fixes

| Violation | Correct Pattern | See |
|-----------|----------------|-----|
| `class XImpl : X` (public) | `internal class XImpl : X` | `patterns/di_patterns.md` |
| Missing factory function | `fun X(...): X = XImpl(...)` | `patterns/di_patterns.md` |
| `suspend fun get(): T?` | `suspend fun get(): Either<RepoError, T>` | `patterns/error_handling_patterns.md` |
| `private val scope = ...` | `viewModelScope: CoroutineScope` param | `patterns/viewmodel_patterns.md` |
| `init { loadData() }` | `override fun onStart(owner: LifecycleOwner) { ... }` | `patterns/viewmodel_patterns.md` |
| `_state: MutableStateFlow<List<T>>` | `_state: MutableStateFlow<ImmutableList<T>>` | `patterns/viewmodel_patterns.md` |
| Empty use case | Call repository directly from ViewModel | `patterns/architecture_patterns.md` |
| `:data`, `:ui` exported to iOS | Only `:api`, `:presentation`, `:core:*` | `patterns/architecture_patterns.md` |
| @Composable without @Preview | Add `@Preview` with realistic data | `patterns/testing_patterns.md` |
| Manual cast after `shouldBeInstanceOf` | Use smart cast directly | `tech/kotest_smart_casting_quick_ref.md` |
| Thread.sleep() in tests | Use Turbine + testScope | `patterns/testing_patterns.md` |

## Critical DON'Ts (Top 10)

1. ‚ùå **NEVER run iOS builds** unless explicitly required (5-10min builds)
2. ‚ùå **NEVER store `CoroutineScope` as field** in ViewModels (pass to constructor)
3. ‚ùå **NEVER perform work in `init`** blocks in ViewModels (use lifecycle callbacks)
4. ‚ùå **NEVER return `Result` or nullable** from repositories (use `Either<RepoError, T>`)
5. ‚ùå **NEVER swallow `CancellationException`** (use `Either.catch` which handles it)
6. ‚ùå **NEVER create empty pass-through** use cases (call repos directly)
7. ‚ùå **NEVER export `:data`, `:ui`, or `:wiring`** to iOS (only `:api`, `:presentation`, `:core:*`)
8. ‚ùå **NEVER put business logic in `:shared`** itself (it's an umbrella; logic goes in feature/core modules)
9. ‚ùå **NEVER add DI annotations** to production classes (wire in wiring modules)
10. ‚ùå **NEVER omit @Preview** for @Composable functions (MANDATORY)

## Decision Matrices

### When to Create a New Module?
```
IF defining cross-feature contracts ‚Üí :features:<name>:api (export to iOS)
IF implementing data layer         ‚Üí :features:<name>:data (do NOT export)
IF implementing ViewModels         ‚Üí :features:<name>:presentation (export to iOS)
IF implementing Compose UI         ‚Üí :features:<name>:ui (do NOT export)
IF wiring dependencies             ‚Üí :features:<name>:wiring (do NOT export)
IF shared utilities (3+ features)  ‚Üí :core:util (export to iOS)
IF common domain models            ‚Üí :core:domain (export to iOS)
ELSE modify existing modules
```

### When to Create a Use Case?
```
IF orchestrating 2+ repositories   ‚Üí Create use case
IF applying business rules         ‚Üí Create use case
IF single repository call only     ‚Üí Call directly from ViewModel
```

### When to Use expect/actual?
```
IF platform-specific API access    ‚Üí Use expect/actual in feature/core modules
IF platform-specific UI:
  - Android/Desktop               ‚Üí Use Compose source sets (androidMain, jvmMain)
  - iOS Production                ‚Üí Use SwiftUI in :iosApp (separate from Compose)
  - iOS Experimental              ‚Üí Use Compose in :iosAppCompose (shares UI)
IF shared business logic           ‚Üí Use commonMain in feature/core modules
IF simple constants                ‚Üí Use commonMain in appropriate module
```

### When to Remove Redundant Tests?
```
1. Does a property test cover this scenario?        ‚Üí Remove concrete test
2. Is this an edge case not covered by properties?  ‚Üí Keep concrete test
3. Does this test document important behavior?      ‚Üí Keep but add comment
4. Is this test redundant with another test?        ‚Üí Merge or remove
```

## Version Catalog Reference

Add dependencies to `gradle/libs.versions.toml`:

```toml
[versions]
arrow = "1.2.0"
koin = "4.0.0"

[libraries]
arrow-core = { module = "io.arrow-kt:arrow-core", version.ref = "arrow" }
koin-core = { module = "io.insert-koin:koin-core", version.ref = "koin" }

[plugins]
kotlin-multiplatform = { id = "org.jetbrains.kotlin.multiplatform", version.ref = "kotlin" }
```

Use in `build.gradle.kts`:
```kotlin
kotlin {
    sourceSets {
        commonMain.dependencies {
            implementation(libs.arrow.core)
            implementation(libs.koin.core)
        }
    }
}
```

## Minimum Test Coverage (Per File)

**Repositories:**
- ‚úÖ Success path (returns Right)
- ‚úÖ Error paths (Network, Http, Unknown)
- ‚úÖ All error types tested
- ‚úÖ Property tests for HTTP code ranges

**ViewModels:**
- ‚úÖ Initial state
- ‚úÖ Loading ‚Üí Success flow
- ‚úÖ Loading ‚Üí Error flow
- ‚úÖ Event handling
- ‚úÖ Property tests for state transitions

**Mappers:**
- ‚úÖ Property-based tests (data preservation)
- ‚úÖ Edge cases (empty, null, boundaries)
- ‚úÖ Round-trip tests

**@Composable:**
- ‚úÖ At least one @Preview with realistic data
- ‚úÖ Recommended: Multiple previews for different states (loading, error, content)

## See Also

**Pattern Files:**
- `patterns/architecture_patterns.md` ‚Äî Split-by-layer, modules, convention plugins
- `patterns/di_patterns.md` ‚Äî Koin DI, Impl+Factory, wiring
- `patterns/error_handling_patterns.md` ‚Äî Either boundaries, sealed errors
- `patterns/viewmodel_patterns.md` ‚Äî Lifecycle-aware, parametric, pagination
- `patterns/navigation_patterns.md` ‚Äî Navigation 3, route objects, animations
- `patterns/testing_patterns.md` ‚Äî Kotest+MockK, property tests, Turbine

**Tech Guides:**
- `tech/conventions.md` ‚Äî Master reference (start here)
- `tech/dependency_injection.md` ‚Äî Comprehensive Koin guide
- `tech/repository.md` ‚Äî Repository patterns, Either, error handling
- `tech/presentation_layer.md` ‚Äî ViewModel lifecycle, UI state
- `tech/navigation.md` ‚Äî Navigation 3 complete guide
- `tech/testing_strategy.md` ‚Äî Testing enforcement, property tests
- `tech/ios_integration.md` ‚Äî iOS SwiftUI + KMP patterns

**Project Guides:**
- `project/prd.md` ‚Äî Product requirements (PRIMARY REFERENCE)
- `project/user_flow.md` ‚Äî User journeys and flows
- `project/ui_ux.md` ‚Äî UI/UX guidelines

**Main Documentation:**
- `AGENTS.md` ‚Äî Autonomous agent workflows
- `.github/copilot-instructions.md` ‚Äî GitHub Copilot context
- `.junie/guidelines.md` ‚Äî Junie AI assistant reference
